# =================================================================================
# Android CI/CD 工作流
# ---------------------------------------------------------------------------------
# 当代码被推送到 master 分支时，此工作流将自动触发。
# 它会执行以下操作：
# 1. 设置 Java 和 Gradle 环境。
# 2. 使用 Gradle 构建并签名 Release 版本的 APK。
# 3. 计算构建产物的 SHA256 哈希值并生成构建摘要。
# 4. 将所有 APK 和元数据文件作为构建产物上传。
# 5. 发送构建结果和 APK 文件到指定的 Telegram 频道。
# =================================================================================

name: Android CI

# 定义工作流的触发条件
on:
  push:
    branches: [ "master" ]
    # 当推送仅涉及以下文件类型时，不触发工作流，以节省资源。
    paths-ignore:
      - '**.md'
      - '**.txt'
      - '.gitignore'
      - '.github/*'
      - '.idea/**'
      - '!.github/workflows/**' # 例外规则：确保对工作流本身的修改能触发 CI

# 为工作流中的所有作业设置默认权限。
permissions:
  contents: write # 允许写入内容，例如创建 GitHub Release。
  actions: write  # 允许操作 Actions，例如取消工作流。
  packages: write # 允许写入 GitHub Packages。

# 定义工作流中的作业
jobs:
  build-and-release: # 作业的唯一ID

    runs-on: ubuntu-latest # 指定作业运行在最新版的 Ubuntu 虚拟环境中。

    steps:
      # 第 1 步：检出代码
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 获取所有历史提交记录，以便 `git rev-list` 可以正确计算版本号。

      # 第 2 步：设置 JDK 环境
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'        # 指定 Java 版本为 21。
          distribution: 'temurin'   # 使用 Eclipse Temurin 发行版。
          cache: gradle             # 启用 Gradle 依赖项的缓存，以加快后续构建速度。

      # 第 3 步：设置签名密钥库
      - name: Setup Keystore
        run: echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 --decode > keystore.jks

      # 第 4 步：构建并签名应用
      - name: Build with Gradle
        run: |
          chmod +x gradlew # 授予 gradlew 脚本执行权限。
          ./gradlew assembleRelease
        env:
          KEYSTORE_PATH: "../keystore.jks"
          KEYSTORE_PASSWORD: ${{ secrets.KEY_STORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}

      # 第 5 步：准备构建产物信息
      - name: Prepare Artifacts and Generate Summary
        id: artifacts
        run: |
          apk_dir="app/build/outputs/apk/release"
          apk_file_armeabi=$(find "$apk_dir" -name 'OShin_armeabi-v7a_v*.apk')
          apk_file_arm64=$(find "$apk_dir" -name 'OShin_arm64-v8a_v*.apk')
          apk_file_armall=$(find "$apk_dir" -name 'OShin_all_v*.apk')
          
          if [ -z "$apk_file_armall" ]; then
            echo "::error::Universal APK not found! Build may have failed to produce artifacts."
            exit 1
          fi
          
          echo "APK_FILE_ARMEABI=$apk_file_armeabi" >> $GITHUB_ENV
          echo "APK_FILE_ARM64=$apk_file_arm64" >> $GITHUB_ENV
          echo "APK_FILE_ARMALL=$apk_file_armall" >> $GITHUB_ENV
          
          sha_armeabi=$(sha256sum "$apk_file_armeabi" | awk '{print $1}')
          sha_arm64=$(sha256sum "$apk_file_arm64" | awk '{print $1}')
          sha_armall=$(sha256sum "$apk_file_armall" | awk '{print $1}')
          
          echo "sha_armeabi=$sha_armeabi" >> $GITHUB_OUTPUT
          echo "sha_arm64=$sha_arm64" >> $GITHUB_OUTPUT
          echo "sha_armall=$sha_armall" >> $GITHUB_OUTPUT
          
          {
            echo "### OShin 构建成功 :rocket:"
            echo ""
            echo "| 架构 | SHA256 哈希 |"
            echo "|:---|:---|"
            echo "| armeabi-v7a | \`$sha_armeabi\` |"
            echo "| arm64-v8a | \`$sha_arm64\` |"
            echo "| all | \`$sha_armall\` |"
          } >> $GITHUB_STEP_SUMMARY

      # 第 6 步：上传构建产物
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: OShin-Build-${{ github.sha }}
          path: app/build/outputs/apk/release/

      # 第 7 步：发送通知到 Telegram
      - name: Send Notification to Telegram
        env:
          # 定义要发送的消息内容
          TELEGRAM_MESSAGE: |
            🚀 **OShin 新版本构建完成！**
            
            **提交信息:**
            ```
            ${{ github.event.head_commit.message }}
            ```
            🔗 **查看本次提交:** [${{ github.sha }}](${{ github.event.head_commit.url }})
        run: |
          # 使用 Python 对消息内容进行转义和编码，以适配 Telegram API 的 sendMediaGroup URL 参数格式
          ESCAPED_MESSAGE=$(python3 -c '
          import json, os, re, urllib.parse;
          msg = os.environ["TELEGRAM_MESSAGE"];
          # 为 MarkdownV2 转义所有必要的特殊字符
          escape_chars = r"_[]()~`>#+-=|{}.!";
          for char in escape_chars:
              msg = msg.replace(char, "\\" + char);
          # 使用 json.dumps 处理引号等，然后进行 URL 编码
          print(urllib.parse.quote(json.dumps(msg)));
          ')
          
          # 使用 curl 调用 sendMediaGroup 方法发送带文件的消息
          # 这是用户原始工作流中验证过可以成功发送的方法
          curl "https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMediaGroup?chat_id=${{ secrets.TELEGRAM_TO }}&media=%5B%7B%22type%22%3A%22document%22%2C%22media%22%3A%22attach%3A%2F%2Fapkfile%22%2C%22parse_mode%22%3A%22MarkdownV2%22%2C%22caption%22%3A$ESCAPED_MESSAGE%7D%5D" \
               -F apkfile=@"${{ env.APK_FILE_ARMALL }}"
